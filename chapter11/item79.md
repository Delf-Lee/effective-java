# 아이템 79. 과도한 동기화는 피하라
### 응답 불가와 안전 실패
### 관찰자(Observer) 패턴

### 락 분할
### 락 정밀도 높이기

락을 점유하고 있는 시간을 최대한 줄이고, 락을 확보하기 위해 경쟁하는 시간을 줄일 수 있는 또 다른 방법으로는
스레드에서 해당 락을 덜 사용하도록 변경하는 방법이 있다.

락 분할(splitting) 과 락 스트라이핑(striping) 이 그 방법들이다.

두 가지 모두 하나의 락으로 여러 개의 상태 변수를 한번에 묶어두지 않고,
서로 다른 락을 사용해 여러 개의 독립적인 상태 변수를 각자 묶어두는 방법이다.
두 가지 기법을 활용하면 락으로 묶이는 프로그램의 범위를 조밀하게 나누는 효과가 있으며,
따라서 결국 앱의 확장성이 높아지는 결과를 기대할 수 있다.

하지만 반대로 락의 개수가 많아질수록 데드락이 발생할 위험도 높아진다는 점을 주의해야 한다.

락을 하나에서 둘로 분할하는 방법은 경쟁 조건이 아주 심하지는 않지만 그래도 어느 정도 경쟁이 발생하고 있는 경우에 가장 큰 효과를 볼 수 있다.
반대로 경쟁 상황이 거의 발생하지 않는 경우에는 락을 분할한다고 해서 큰 효과를 보지는 못하지만,
부하가 걸리면서 경쟁이 발생하기 시작했을 때 성능이 떨어지는 시점을 늦출 수도 있다.

어느 정도의 경쟁이 발생하는 상황에서 락을 두 개 이상으로 분할하면 대부분의 동기화 블록에서 락 경쟁이 일어나지 않도록 할 수 있으며, 따라서 처리량과 확장성의 측면에서 큰 이득을 얻을 수 있다.



#### 락 스트라이핑

락 분할 방법은 때에 따라 독립적인 객체를 여러 가지 크기의 단위로 묶어내고,
묶인 블록을 단위로 락을 나누는 방법을 사용할 수도 있는데, 이런 방법을 락 스트라이핑이라고 한다. ( lock striping )

예를 들어 ConcurrentHashMap 클래스가 구현된 소스코드를 보면 16개의 락을 배열로 마련해두고
16개의 락 각자가 전체 해시 범위의 1/16에 대한 락을 담당한다.
따라서 N번째 해시 값은 락 배열에서 N mod 16 의 값에 해당하는 락으로 동기화된다.
ConcurrentHashMap 에서 사용하는 해시 함수가 적당한 수준 이상으로 맵에 들어 있는 항목을 분산시켜 준다는 가정하에 락 경쟁이 발생할 확률을 1/16으로 낮추는 효과가 있다.

결국 ConcurrentHashMap 은 최대 16개의 스레드에서 경쟁 없이 동시에 맵에 들어 있는 데이터를 사용할 수 있도록 구현돼 있는 셈이다.
( CPU 개수가 많은 하드웨어를 사용하는 경우 병렬성을 높이기 위해 락의 개수를 더 늘려볼 수도 있다.
하지만 적절한 수치 이상의 많은 경쟁 조건이 발생한다고 확인된 경우에만 기본값인 16보다 큰 값을 사용하자. )


락 스트라이핑을 사용하다 보면 여러 개의 락을 사용하도록 쪼개놓은 컬렉션 전체를 한꺼번에 독점적으로 사용해야 할 필요가 있을 수 있는데,
이런 경우에는 단일 락을 사용할 때보다 동기화시키기 어렵고 자원 소모도 많이 한다는 단점이 있다.
대부분의 작업을 처리할 때는 쪼개진 락 하나만 확보하는 것으로도 충분하지만,
ConcurrentHashMap 클래스에서 해시 공간의 크기를 늘리고 해시 함수를 새롭게 적용하는 작업과 같이 간혹 전체 컬렉션을 독점적으로 사용해야 하는 경우가 생긴다.
이런 경우에는 보통 쪼개진 락을 전부 확보한 이후에 처리하도록 구현한다.


출처: https://aroundck.tistory.com/4529 [돼지왕 왕돼지 놀이터]