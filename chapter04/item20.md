# 아이템 20. 추상 클래스보다는 인터페이스를 우선하라
자바가 제공하는 다중 구현 메커니즘은 **인터페이스**와 **추상 클래스**가 있다.
- **추상 클래스**는 추상 클래스가 정의한 타입을 구현하는 클래스를 반드시 추상클래스의 하위 클래스가 되어야 한다.
- **인터페이스**는 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 어떤 클래스를 상속했든 같은 타입으로 취급된다.

## 믹스인(mixin)
- 믹스인이란 클래스가 구현할 수 있는 타입으로 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 **특정 선택적 행위를 제공한다고 선언하는 효과**를 준다.
- 추상클래스로는 기존 클래스에 덧씌울 수 없기 때문에 믹스인을 정의할 수 없다.

## 인터페이스의 특징
- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.
- 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.
  - 클래스는 두 개 이상의 클래스를 상속 받을 수 없다.
  - 현실에는 계층을 엄격히 구분하기 어려운 개념도 있다.
- 클래스로만 정의한다면 조합 폭팔(combinational explosion)이라고 부르는 현상이 일어날 것이다.
  - 이렇게 된다면 '공통 기능'을 정의해놓은 타입이 없으니, 자칫 매개변수 타입만 다른 메서드들을 수없이 많이 가진 거대한 클래스를 낳을 수 있다.

## 디폴트 메서드(default method)
Java 8에서는 디폴트 메서드라는 것을 사용하여 메서드 구현을 포함하는 인터페이스를 정의할 수 있다. 인터페이스에서 이미 구현을 했으니 해당 인터페이스를 구현하는 클래스에서는 추가된 메서드의 구현을 추가적으로 할 필요가 없다. 결과적으로 기존 인터페이스를 구현하는 클래스는 자동으로 인터페이스에 추가된 새로운 메서드의 디폴트 메서드를 상속받게 된다.

디폴트 메서드를 활용하면 자바 API의 호환성을 유지하면서 라이브러리를 변경할 수 있다.
기존에는 이미 공개된 라이브러리를 수정할 때 인터페이스에 메서드를 추가하게 되면 해당 인터페이스를 구현하고 있는 클래스에 모두 메서드를 구현해줘야 했지만 디폴트 메서드를 통해 구현하면 그렇게 하지 않아도 된다. 훨씬 더 유연해진 것이다.

## 추상 골격 구현(skeletal implementation) 클래스
인터페이스 뿐만 아니라 추상 골격 구현 클래스를 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다.

- **인터페이스로**는 타입을 정의하고, 필요하면 디폴트 메서드 몇 개도 함께 제공한다. 그리고 **골격 구현 클래스**는 나머지 메서드들까지 구현한다.
- 이렇게 해두면 단순히 골겨 구현을 확장하는 것만드로 이 인터페이스를 구현하는 데 필요한 일이 대부분 완료된다.
  - 이게 바로 템플릿 메소드 패턴이다.
- 관례상 클래스명 앞에 `Abstract-`를 붙인다.
- 골겨 구현 클래스의 아름다움은 추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약에서는 자유롭다는 점에 있다.

### 골격 구현 작성
- 인터페이스를 잘 살펴 다른 메서드들의 구현에 사용되는 기반 메서드들을 선정한다.
- 기반 메서드들을 사용해 직접 구현할 수 있는 메서드를 모두 디폴트 메서드로 제공한다.
  - `equals`나 `hashCode`같은  `Object`의 메서드들은 디폴트 메서드로 제공하면 안된다.
- 인터페이스의 메서드가 모두 기반 메서드와 디폴트 메서드가 된다면, 골겨 구현 클래스를 별도로 만들 이유는 없다.
- 기반 메서드나 디폴트 메서드로 만들지 못한 메서드가 남아 있다면, 이 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메서드들을 작성해 넣는다.

### 기타
- 골겨 구현은 기본적으로 상속해서 사용하는걸 가정하므로 설계 및 문서화 지침을 모두 따라야한다.
- 단순구현(simple implementation)은 골격 구현의 작은 변종으로, `AbstractMap.SimpleEntry`가 좋은 예다.
  - 쉽게말해 동작하는 단순한 구현이다.